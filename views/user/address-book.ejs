<div class="container py-4">
  <!-- Breadcrumbs -->
  <%- include('partials/breadcrumb', {
    breadcrumbs: [
      { label: 'Home', href: '/' },
      { label: 'My Profile', href: '/profile' },
      { label: 'Address Book' }
    ]
  }) %>

  <!-- Main Layout: Sidebar + Content -->
  <div class="row g-4">
    <!-- Left Sidebar Navigation -->
    <div class="col-lg-3 col-md-4">
      <%- include('partials/profile-sidebar.ejs', { user: user, active: 'addresses' }) %>
    </div>

    <!-- Main Content Area -->
    <div class="col-lg-9 col-md-8">
      <div class="address-book-container">
        <!-- Header -->
        <div class="address-header">
          <div class="header-content">
            <h2><i class="bi bi-geo-alt me-2"></i> Address Book</h2>
            <p class="text-muted">Manage your delivery addresses</p>
          </div>
          <button class="btn btn-primary add-address-btn" onclick="addNewAddress()">
            <i class="bi bi-plus me-2"></i> Add New Address
          </button>
        </div>

        <!-- Addresses Grid -->
        <div class="addresses-grid" id="addressesGrid">
          <!-- Loading state -->
          <div class="loading-state" id="loadingState">
            <div class="spinner-border" role="status">
              <span class="visually-hidden">Loading...</span>
            </div>
            <p>Loading addresses...</p>
          </div>

          <!-- Empty state -->
          <div class="empty-state" id="emptyState" style="display: none;">
            <div class="empty-icon">
              <i class="bi bi-geo-alt"></i>
            </div>
            <h4>No addresses found</h4>
            <p>Add your first delivery address to get started</p>
            <button class="btn btn-primary" onclick="addNewAddress()">
              <i class="bi bi-plus me-2"></i> Add Address
            </button>
          </div>

          <!-- Addresses will be loaded here -->
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Add/Edit Address Modal -->
<div class="modal fade" id="addressModal" tabindex="-1" aria-labelledby="addressModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="addressModalLabel">
          <i class="bi bi-plus me-2"></i> Add New Address
        </h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <%- include('partials/addresses') %>
      </div>
    </div>
  </div>
</div>

<style>
/* Address Book Styles */
.address-book-container {
  background: #fff;
  border-radius: 12px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
  overflow: hidden;
}

.address-header {
  padding: 2rem;
  border-bottom: 1px solid #e9ecef;
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: 1rem;
}

.header-content h2 {
  margin: 0 0 0.5rem;
  color: #000;
  font-weight: 600;
  display: flex;
  align-items: center;
}

.header-content p {
  margin: 0;
}

.add-address-btn {
  background: #000;
  border: none;
  padding: 0.75rem 1.5rem;
  border-radius: 8px;
  font-weight: 500;
  transition: all 0.3s ease;
}

.add-address-btn:hover {
  background: #dc3545;
  transform: translateY(-1px);
}

/* Addresses Grid */
.addresses-grid {
  padding: 2rem;
  min-height: 400px;
}

.loading-state, .empty-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 300px;
  text-align: center;
  color: #666;
}

.empty-icon {
  font-size: 4rem;
  color: #ddd;
  margin-bottom: 1rem;
}

.empty-state h4 {
  margin-bottom: 0.5rem;
  color: #333;
}

.empty-state p {
  margin-bottom: 1.5rem;
}

/* Address Cards */
.address-card {
  background: #fff;
  border: 2px solid #e9ecef;
  border-radius: 12px;
  padding: 1.5rem;
  margin-bottom: 1.5rem;
  transition: all 0.3s ease;
  position: relative;
}

.address-card:hover {
  border-color: #000;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
}

.address-card.default {
  border-color: #28a745;
  background: linear-gradient(135deg, #f8fff9 0%, #f0fff4 100%);
}

.default-badge {
  position: absolute;
  top: 1rem;
  right: 1rem;
  background: #28a745;
  color: white;
  padding: 0.25rem 0.75rem;
  border-radius: 20px;
  font-size: 0.8rem;
  font-weight: 500;
}

.address-type {
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  background: #f8f9fa;
  padding: 0.5rem 1rem;
  border-radius: 20px;
  font-size: 0.9rem;
  font-weight: 500;
  color: #666;
  margin-bottom: 1rem;
}

.address-details h5 {
  margin: 0 0 0.5rem;
  color: #000;
  font-weight: 600;
}

.address-text {
  color: #666;
  line-height: 1.6;
  margin-bottom: 1rem;
}

.address-actions {
  display: flex;
  gap: 0.75rem;
  flex-wrap: wrap;
}

.btn-sm {
  padding: 0.5rem 1rem;
  font-size: 0.85rem;
  border-radius: 6px;
  font-weight: 500;
}

.btn-outline-primary {
  border-color: #000;
  color: #000;
}

.btn-outline-primary:hover {
  background: #000;
  border-color: #000;
}

.btn-outline-success {
  border-color: #28a745;
  color: #28a745;
}

.btn-outline-success:hover {
  background: #28a745;
  border-color: #28a745;
}

.btn-outline-danger {
  border-color: #dc3545;
  color: #dc3545;
}

.btn-outline-danger:hover {
  background: #dc3545;
  border-color: #dc3545;
}

/* Modal Styles */
.modal-content {
  border: none;
  border-radius: 12px;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
}

.modal-header {
  border-bottom: 1px solid #e9ecef;
  padding: 1.5rem 2rem;
}

.modal-title {
  font-weight: 600;
  color: #000;
}

.modal-body {
  padding: 0;
}

/* Responsive Design */
@media (max-width: 768px) {
  .address-header {
    flex-direction: column;
    align-items: stretch;
    text-align: center;
  }

  .add-address-btn {
    width: 100%;
  }

  .address-actions {
    justify-content: center;
  }
}

@media (max-width: 576px) {
  .addresses-grid {
    padding: 1rem;
  }

  .address-card {
    padding: 1rem;
  }

  .address-header {
    padding: 1.5rem;
  }
}
</style>

<script>
// Initialize Geoapify Autocomplete
class GeoapifyAddressForm {
  constructor(apiKey) {
    this.apiKey = apiKey;
    this.autocomplete = null;
    this.initializeAutocomplete();
    this.setupEventListeners();
  }

  initializeAutocomplete() {
    // Create autocomplete for address input
    const addressInput = document.getElementById('addressDetails');
    if (addressInput && typeof GeocoderAutocomplete !== 'undefined') {
      try {
        this.autocomplete = new GeocoderAutocomplete(addressInput, this.apiKey, {
          placeholder: 'Start typing your address...',
          type: 'locality', // Changed from 'address' to 'locality' for better results
          lang: 'en',
          countries: ['in'],
          limit: 5,
          debounceDelay: 300,
          skipIcons: false,
          skipDetails: false
        });

        // Handle address selection
        this.autocomplete.on('select', (location) => {
          console.log('Address selected:', location);
          this.fillAddressForm(location);
        });

        // Handle suggestions
        this.autocomplete.on('suggestions', (suggestions) => {
          console.log('Address suggestions received:', suggestions);
        });

        // Handle input events
        this.autocomplete.on('input', (query) => {
          console.log('Address input:', query);
        });

        console.log('‚úÖ Geoapify autocomplete initialized successfully');
      } catch (error) {
        console.error('‚ùå Error initializing Geoapify autocomplete:', error);
        // Fallback to manual search
        this.setupManualSearch();
      }
    } else {
      console.warn('‚ö†Ô∏è GeocoderAutocomplete not available, setting up manual search');
      this.setupManualSearch();
    }
  }

  setupManualSearch() {
    const addressInput = document.getElementById('addressDetails');
    if (addressInput) {
      let searchTimeout;
      
      addressInput.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        const query = e.target.value.trim();
        
        if (query.length >= 3) {
          searchTimeout = setTimeout(() => {
            this.performManualSearch(query);
          }, 500);
        }
      });
    }
  }

  async performManualSearch(query) {
    try {
      const response = await fetch(
        `https://api.geoapify.com/v1/geocode/autocomplete?text=${encodeURIComponent(query)}&country=IN&format=json&apiKey=${this.apiKey}&limit=5`
      );
      
      if (response.ok) {
        const data = await response.json();
        if (data.results && data.results.length > 0) {
          this.showManualSuggestions(data.results);
        }
      }
    } catch (error) {
      console.error('Manual search error:', error);
    }
  }

  showManualSuggestions(suggestions) {
    // Remove existing suggestions
    const existingSuggestions = document.querySelector('.manual-address-suggestions');
    if (existingSuggestions) {
      existingSuggestions.remove();
    }

    const addressInput = document.getElementById('addressDetails');
    const suggestionsContainer = document.createElement('div');
    suggestionsContainer.className = 'manual-address-suggestions';
    suggestionsContainer.style.cssText = `
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      z-index: 1000;
      background: white;
      border: 1px solid #ddd;
      border-top: none;
      border-radius: 0 0 6px 6px;
      max-height: 200px;
      overflow-y: auto;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    `;

    suggestions.forEach((suggestion, index) => {
      const suggestionItem = document.createElement('div');
      suggestionItem.className = 'manual-suggestion-item';
      suggestionItem.style.cssText = `
        padding: 12px 15px;
        cursor: pointer;
        border-bottom: 1px solid #f8f9fa;
        font-size: 0.9rem;
        color: #333;
        transition: all 0.2s ease;
      `;
      suggestionItem.textContent = suggestion.formatted;
      
      suggestionItem.addEventListener('mouseenter', () => {
        suggestionItem.style.backgroundColor = '#f8f9fa';
      });
      
      suggestionItem.addEventListener('mouseleave', () => {
        suggestionItem.style.backgroundColor = 'white';
      });
      
      suggestionItem.addEventListener('click', () => {
        addressInput.value = suggestion.formatted;
        this.fillAddressForm({ properties: suggestion });
        suggestionsContainer.remove();
      });
      
      suggestionsContainer.appendChild(suggestionItem);
    });

    // Position the suggestions container
    const inputContainer = addressInput.parentNode;
    inputContainer.style.position = 'relative';
    inputContainer.appendChild(suggestionsContainer);

    // Hide suggestions when clicking outside
    document.addEventListener('click', (e) => {
      if (!inputContainer.contains(e.target)) {
        suggestionsContainer.remove();
      }
    }, { once: true });
  }

  fillAddressForm(location) {
    const properties = location.properties;

    // Auto-fill form fields
    if (properties.state) {
      document.getElementById('state').value = properties.state;
      this.updateDistricts(properties.state, properties.county);
    }

    if (properties.city) {
      document.getElementById('city').value = properties.city;
    }

    if (properties.postcode) {
      document.getElementById('pincode').value = properties.postcode;
    }

    if (properties.county) {
      // Wait for districts to load, then select
      setTimeout(() => {
        document.getElementById('district').value = properties.county;
      }, 100);
    }

    // Clear any validation errors
    this.clearValidationErrors();
  }

  setupEventListeners() {
    // Pincode-based location fetching as fallback
    const pincodeInput = document.getElementById('pincode');
    if (pincodeInput) {
      pincodeInput.addEventListener('blur', async (e) => {
        const pincode = e.target.value.trim();
        if (pincode.length === 6 && !document.getElementById('city').value) {
          await this.fetchLocationByPincode(pincode);
        }
      });
    }

    // Current location button
    this.addCurrentLocationButton();
  }

  async fetchLocationByPincode(pincode) {
    try {
      console.log(`üîç Fetching location for pincode: ${pincode}`);
      
      const response = await fetch(
        `https://api.geoapify.com/v1/geocode/search?text=${pincode}&country=IN&format=json&apiKey=${this.apiKey}`
      );
      const data = await response.json();

      console.log('Pincode search results:', data);

      if (data.results && data.results.length > 0) {
        const location = data.results[0];
        console.log('Auto-filling from pincode:', location);
        
        // Auto-fill the form with pincode data
        if (location.state) {
          const stateSelect = document.getElementById('state');
          // Try to match state name to our dropdown options
          const stateOptions = Array.from(stateSelect.options);
          const matchingState = stateOptions.find(option => 
            option.textContent.toLowerCase().includes(location.state.toLowerCase()) ||
            location.state.toLowerCase().includes(option.textContent.toLowerCase())
          );
          
          if (matchingState) {
            stateSelect.value = matchingState.value;
            console.log(`‚úÖ State set to: ${matchingState.textContent}`);
            
            // Call the updateDistricts function directly (defined in addresses partial)
            if (typeof updateDistricts === 'function') {
              updateDistricts(matchingState.value);
              console.log(`‚úÖ Districts loaded for state: ${matchingState.textContent}`);
              
              // Wait for districts to load, then auto-select district
              setTimeout(() => {
                this.autoSelectDistrict(location.county || location.city);
              }, 300);
            } else {
              // Fallback: trigger change event
              stateSelect.dispatchEvent(new Event('change'));
              setTimeout(() => {
                this.autoSelectDistrict(location.county || location.city);
              }, 300);
            }
          }
        }

        // Auto-fill city
        if (location.county) {
          document.getElementById('city').value = location.county;
          console.log(`‚úÖ City set to: ${location.county}`);
        } else if (location.city) {
          document.getElementById('city').value = location.city;
          console.log(`‚úÖ City set to: ${location.city}`);
        }

        // Show success message
        const pincodeInput = document.getElementById('pincode');
        pincodeInput.style.borderColor = '#28a745';
        setTimeout(() => {
          pincodeInput.style.borderColor = '';
        }, 2000);

        this.clearValidationErrors();
      } else {
        console.warn('No results found for pincode:', pincode);
        // Show warning for invalid pincode
        const pincodeInput = document.getElementById('pincode');
        pincodeInput.style.borderColor = '#ffc107';
        setTimeout(() => {
          pincodeInput.style.borderColor = '';
        }, 2000);
      }
    } catch (error) {
      console.error('Error fetching location by pincode:', error);
      // Show error state
      const pincodeInput = document.getElementById('pincode');
      pincodeInput.style.borderColor = '#dc3545';
      setTimeout(() => {
        pincodeInput.style.borderColor = '';
      }, 2000);
    }
  }

  autoSelectDistrict(districtName) {
    if (!districtName) return;
    
    const districtSelect = document.getElementById('district');
    if (districtSelect.disabled) {
      console.warn('District dropdown is still disabled, retrying...');
      setTimeout(() => {
        this.autoSelectDistrict(districtName);
      }, 100);
      return;
    }

    console.log(`üîç Looking for district: ${districtName}`);
    
    // Try to find matching district option
    const districtOptions = Array.from(districtSelect.options);
    const matchingDistrict = districtOptions.find(option => {
      const optionText = option.textContent.toLowerCase();
      const searchText = districtName.toLowerCase();
      
      // Try exact match first
      if (optionText === searchText) return true;
      
      // Try partial matches
      if (optionText.includes(searchText) || searchText.includes(optionText)) return true;
      
      // Try without common words
      const cleanOptionText = optionText.replace(/\b(district|taluk|tehsil)\b/g, '').trim();
      const cleanSearchText = searchText.replace(/\b(district|taluk|tehsil)\b/g, '').trim();
      
      return cleanOptionText === cleanSearchText || 
             cleanOptionText.includes(cleanSearchText) || 
             cleanSearchText.includes(cleanOptionText);
    });

    if (matchingDistrict) {
      districtSelect.value = matchingDistrict.value;
      console.log(`‚úÖ District set to: ${matchingDistrict.textContent}`);
      
      // Add visual feedback
      districtSelect.style.borderColor = '#28a745';
      setTimeout(() => {
        districtSelect.style.borderColor = '';
      }, 2000);
    } else {
      console.warn(`‚ùå Could not find matching district for: ${districtName}`);
      console.log('Available districts:', districtOptions.map(opt => opt.textContent));
      
      // Show warning that district needs manual selection
      districtSelect.style.borderColor = '#ffc107';
      setTimeout(() => {
        districtSelect.style.borderColor = '';
      }, 3000);
    }
  }

  addCurrentLocationButton() {
    const addressDetails = document.getElementById('addressDetails');
    if (addressDetails && navigator.geolocation) {
      // Check if button already exists
      const existingBtn = addressDetails.parentNode.querySelector('.btn-current-location');
      if (existingBtn) {
        return; // Button already exists, don't add another
      }

      // Create "Use Current Location" button
      const locationBtn = document.createElement('button');
      locationBtn.type = 'button';
      locationBtn.className = 'btn btn-outline-dark btn-sm mt-2 btn-current-location'; // Added unique class
      locationBtn.innerHTML = '<i class="fas fa-location-arrow me-1"></i>Use Current Location';
      locationBtn.style.cssText = `
        background-color: #000;
        border-color: #000;
        color: #fff;
        transition: all 0.3s ease;
      `;
      
      // Add hover effect
      locationBtn.addEventListener('mouseenter', () => {
        locationBtn.style.backgroundColor = '#dc3545';
        locationBtn.style.borderColor = '#dc3545';
        locationBtn.style.transform = 'translateY(-1px)';
      });
      
      locationBtn.addEventListener('mouseleave', () => {
        locationBtn.style.backgroundColor = '#000';
        locationBtn.style.borderColor = '#000';
        locationBtn.style.transform = 'translateY(0)';
      });
      locationBtn.addEventListener('click', () => {
        this.getCurrentLocation();
      });

      addressDetails.parentNode.appendChild(locationBtn);
    }
  }

  async getCurrentLocation() {
    if (!navigator.geolocation) {
      alert('Geolocation is not supported by this browser.');
      return;
    }

    navigator.geolocation.getCurrentPosition(async (position) => {
      const { latitude, longitude } = position.coords;
      try {
        const response = await fetch(
          `https://api.geoapify.com/v1/geocode/reverse?lat=${latitude}&lon=${longitude}&format=json&apiKey=${this.apiKey}`
        );
        const data = await response.json();

        if (data.results && data.results.length > 0) {
          const location = data.results[0];
          this.fillAddressForm({ properties: location });
          document.getElementById('addressDetails').value = location.formatted;
        }
      } catch (error) {
        console.error('Error getting current location:', error);
        alert('Could not get your current location. Please enter address manually.');
      }
    }, (error) => {
      console.error('Geolocation error:', error);
      alert('Could not access your location. Please enter address manually.');
    });
  }

  updateDistricts(selectedState, selectedDistrict = '') {
    // Your existing state-district logic here
    const districtSelect = document.getElementById('district');
    if (typeof stateDistrictData !== 'undefined' && stateDistrictData[selectedState]) {
      districtSelect.disabled = false;
      districtSelect.innerHTML = '<option value="">Select District</option>';

      stateDistrictData[selectedState].districts.forEach(district => {
        const option = document.createElement('option');
        option.value = district.toLowerCase().replace(/\s+/g, '-');
        option.textContent = district;
        districtSelect.appendChild(option);
      });

      if (selectedDistrict) {
        districtSelect.value = selectedDistrict.toLowerCase().replace(/\s+/g, '-');
      }
    }
  }

  clearValidationErrors() {
    document.querySelectorAll('.is-invalid').forEach(input => {
      input.classList.remove('is-invalid');
    });

    document.querySelectorAll('.error-message').forEach(error => {
      error.style.display = 'none';
    });
  }
}

let addresses = [];
let currentEditingId = null;

// Load addresses on page load
document.addEventListener('DOMContentLoaded', function() {
  loadAddresses();
  
  // Initialize Geoapify when modal is shown
  const addressModal = document.getElementById('addressModal');
  if (addressModal) {
    addressModal.addEventListener('shown.bs.modal', function() {
      // Initialize Geoapify with secure API key from backend
      const API_KEY = '<%= geoapifyApiKey %>';
      new GeoapifyAddressForm(API_KEY);
    });
  }
});

// Load addresses from API
async function loadAddresses() {
  try {
    console.log('üîÑ Loading addresses...');
    const response = await fetch('/api/addresses');
    console.log('üì° Response status:', response.status);
    console.log('üì° Response headers:', response.headers);
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    console.log('üì¶ Response data:', data);

    if (data && data.success) {
      addresses = data.addresses || [];
      console.log('‚úÖ Addresses loaded:', addresses.length, 'addresses');
      renderAddresses();
    } else {
      console.error('‚ùå API returned error:', data ? data.message : 'Unknown error');
      console.error('‚ùå Full response data:', data);
      showError(data && data.message ? data.message : 'Failed to load addresses - unknown error');
    }
  } catch (error) {
    console.error('‚ùå Error loading addresses:', error);
    console.error('‚ùå Error details:', {
      name: error.name,
      message: error.message,
      stack: error.stack
    });
    showError(`Failed to load addresses: ${error.message}`);
  } finally {
    console.log('üèÅ Hiding loading state');
    const loadingState = document.getElementById('loadingState');
    if (loadingState) {
      loadingState.style.display = 'none';
    }
  }
}

// Render addresses in the grid
function renderAddresses() {
  const grid = document.getElementById('addressesGrid');
  const emptyState = document.getElementById('emptyState');
  
  // Check if required elements exist
  if (!grid) {
    console.error('‚ùå addressesGrid element not found');
    return;
  }
  
  if (addresses.length === 0) {
    if (emptyState) {
      emptyState.style.display = 'flex';
    }
    return;
  }

  if (emptyState) {
    emptyState.style.display = 'none';
  }
  
  const addressesHTML = addresses.map(address => `
    <div class="address-card ${address.isDefault ? 'default' : ''}">
      ${address.isDefault ? '<div class="default-badge"><i class="bi bi-star-fill me-1"></i> Default</div>' : ''}
      
      <div class="address-type">
        <i class="bi bi-${getAddressIcon(address.addressType)}"></i>
        ${capitalizeFirst(address.addressType)}
      </div>
      
      <div class="address-details">
        <h5>${address.name}</h5>
        <div class="address-text">
          ${address.landMark}<br>
          ${address.city}, ${address.state} - ${address.pincode}<br>
          <strong>Phone:</strong> ${address.phone}
          ${address.altPhone ? `<br><strong>Alt Phone:</strong> ${address.altPhone}` : ''}
        </div>
      </div>
      
      <div class="address-actions">
        <button class="btn btn-outline-primary btn-sm" onclick="editAddress('${address._id}')">
          <i class="bi bi-pencil me-1"></i> Edit
        </button>
        ${!address.isDefault ? `
          <button class="btn btn-outline-success btn-sm" onclick="setDefaultAddress('${address._id}')">
            <i class="bi bi-star me-1"></i> Set Default
          </button>
        ` : ''}
        <button class="btn btn-outline-danger btn-sm" onclick="deleteAddress('${address._id}')">
          <i class="bi bi-trash me-1"></i> Delete
        </button>
      </div>
    </div>
  `).join('');

  grid.innerHTML = addressesHTML;
}

// Helper functions
function getAddressIcon(type) {
  switch(type) {
    case 'home': return 'house';
    case 'office': return 'briefcase';
    case 'other': return 'geo-alt';
    default: return 'geo-alt';
  }
}

function capitalizeFirst(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

// Add new address
function addNewAddress() {
  currentEditingId = null;
  document.getElementById('addressModalLabel').innerHTML = '<i class="bi bi-plus me-2"></i> Add New Address';
  
  // Reset form
  const form = document.getElementById('addressForm');
  if (form) {
    form.reset();
    // Clear any validation states
    form.querySelectorAll('.is-invalid, .is-valid').forEach(el => {
      el.classList.remove('is-invalid', 'is-valid');
    });
    form.querySelectorAll('.error-message').forEach(el => {
      el.style.display = 'none';
    });
  }
  
  const modal = new bootstrap.Modal(document.getElementById('addressModal'));
  modal.show();
}

// Edit address
async function editAddress(addressId) {
  currentEditingId = addressId;
  document.getElementById('addressModalLabel').innerHTML = '<i class="bi bi-pencil me-2"></i> Edit Address';
  
  const address = addresses.find(addr => addr._id === addressId);
  if (!address) return;

  // Populate form with address data
  const form = document.getElementById('addressForm');
  if (form) {
    form.querySelector('#fullName').value = address.name;
    form.querySelector('#mobileNumber').value = address.phone;
    form.querySelector('#altPhone').value = address.altPhone || '';
    form.querySelector('#addressDetails').value = address.landMark;
    form.querySelector('#state').value = address.state;
    form.querySelector('#city').value = address.city;
    form.querySelector('#pincode').value = address.pincode;
    form.querySelector(`input[name="addressType"][value="${address.addressType}"]`).checked = true;
    form.querySelector('#makeDefault').checked = address.isDefault;
  }
  
  const modal = new bootstrap.Modal(document.getElementById('addressModal'));
  modal.show();
}

// Set default address
async function setDefaultAddress(addressId) {
  try {
    console.log('üîÑ Setting default address:', addressId);
    
    const response = await fetch(`/api/address/${addressId}/default`, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json'
      }
    });

    console.log('üì° Set default response status:', response.status);
    console.log('üì° Set default response headers:', response.headers);
    
    // Check if response is ok
    if (!response.ok) {
      const errorText = await response.text();
      console.error('‚ùå HTTP error response:', errorText);
      throw new Error(`HTTP error! status: ${response.status}, response: ${errorText}`);
    }

    // Check if response is JSON
    const contentType = response.headers.get('content-type');
    if (!contentType || !contentType.includes('application/json')) {
      const responseText = await response.text();
      console.error('‚ùå Non-JSON response:', responseText);
      throw new Error(`Expected JSON response but got: ${contentType}, content: ${responseText}`);
    }

    const data = await response.json();
    console.log('üì¶ Set default response data:', data);

    if (data && data.success) {
      console.log('‚úÖ Default address set successfully');
      showSuccess(data.message || 'Default address updated successfully');
      
      // Update the addresses array directly instead of reloading from API
      console.log('üîÑ Updating addresses array directly...');
      addresses.forEach(addr => {
        addr.isDefault = addr._id === addressId;
      });
      
      // Re-render the addresses with updated data
      console.log('üé® Re-rendering addresses...');
      renderAddresses();
      
      console.log('‚úÖ UI updated successfully without API call');
    } else {
      console.error('‚ùå Backend returned error:', data ? data.message : 'Unknown error');
      console.error('‚ùå Full response data:', data);
      showError(data && data.message ? data.message : 'Failed to set default address - unknown error');
    }
  } catch (error) {
    console.error('‚ùå Error setting default address:', error);
    console.error('‚ùå Error details:', {
      name: error.name,
      message: error.message,
      stack: error.stack
    });
    showError(`Failed to set default address: ${error.message}`);
  }
}

// Delete address
async function deleteAddress(addressId) {
  // Use SweetAlert for confirmation
  if (typeof Swal !== 'undefined') {
    const result = await Swal.fire({
      title: 'Delete Address?',
      text: 'Are you sure you want to delete this address? This action cannot be undone.',
      icon: 'warning',
      showCancelButton: true,
      confirmButtonColor: '#dc3545',
      cancelButtonColor: '#6c757d',
      confirmButtonText: '<i class="bi bi-trash me-1"></i> Yes, Delete',
      cancelButtonText: '<i class="bi bi-x-circle me-1"></i> Cancel',
      reverseButtons: true
    });

    if (!result.isConfirmed) {
      return;
    }
  } else {
    // Fallback to browser confirm if SweetAlert is not available
    if (!confirm('Are you sure you want to delete this address?')) {
      return;
    }
  }

  try {
    const response = await fetch(`/api/address/${addressId}`, {
      method: 'DELETE'
    });

    const data = await response.json();

    if (data.success) {
      showSuccess(data.message);
      loadAddresses(); // Reload addresses
    } else {
      showError(data.message);
    }
  } catch (error) {
    console.error('Error deleting address:', error);
    showError('Failed to delete address');
  }
}

// DISABLED: Override the form submission in the addresses partial
// document.addEventListener('DOMContentLoaded', function() {
//   // Wait for the form to be available
//   setTimeout(() => {
//     const form = document.getElementById('addressForm');
//     if (form) {
//       // Remove existing event listeners
//       const newForm = form.cloneNode(true);
//       form.parentNode.replaceChild(newForm, form);
//       
//       // Add new event listener
//       newForm.addEventListener('submit', handleAddressSubmit);
//     }
//   }, 100);
// });

// Address validation function
async function validateAddress(addressData) {
  const API_KEY = '<%= geoapifyApiKey %>';
  const fullAddress = `${addressData.addressDetails}, ${addressData.city}, ${addressData.state}, ${addressData.pincode}`;
  
  try {
    const response = await fetch(
      `https://api.geoapify.com/v1/geocode/search?text=${encodeURIComponent(fullAddress)}&country=IN&format=json&apiKey=${API_KEY}`
    );
    const data = await response.json();

    return {
      isValid: data.results && data.results.length > 0,
      suggestions: data.results || [],
      coordinates: data.results && data.results.length > 0 ? {
        lat: data.results[0].lat,
        lon: data.results[0].lon
      } : null
    };
  } catch (error) {
    console.error('Address validation error:', error);
    return {
      isValid: false,
      suggestions: [],
      coordinates: null
    };
  }
}

// Check for duplicate addresses using coordinates
function checkDuplicateAddress(newAddress, existingAddresses) {
  if (!newAddress.lat || !newAddress.lon) return false;
  
  const threshold = 0.001; // ~100 meters
  
  return existingAddresses.some(existing => {
    if (!existing.lat || !existing.lon) return false;
    
    const latDiff = Math.abs(existing.lat - newAddress.lat);
    const lonDiff = Math.abs(existing.lon - newAddress.lon);
    
    return latDiff < threshold && lonDiff < threshold;
  });
}

// Show address validation modal
function showAddressValidationModal(suggestions, onConfirm, onCancel) {
  const modalHtml = `
    <div class="modal fade" id="addressValidationModal" tabindex="-1">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title">Address Validation</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
          </div>
          <div class="modal-body">
            <p>We found some suggestions for your address. Please select the most accurate one:</p>
            <div class="address-suggestions">
              ${suggestions.map((suggestion, index) => `
                <div class="form-check mb-2">
                  <input class="form-check-input" type="radio" name="addressSuggestion" id="suggestion${index}" value="${index}">
                  <label class="form-check-label" for="suggestion${index}">
                    ${suggestion.formatted}
                  </label>
                </div>
              `).join('')}
              <div class="form-check mb-2">
                <input class="form-check-input" type="radio" name="addressSuggestion" id="useOriginal" value="original">
                <label class="form-check-label" for="useOriginal">
                  Use my original address as entered
                </label>
              </div>
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
            <button type="button" class="btn btn-primary" id="confirmAddressBtn">Confirm</button>
          </div>
        </div>
      </div>
    </div>
  `;
  
  // Remove existing modal if any
  const existingModal = document.getElementById('addressValidationModal');
  if (existingModal) {
    existingModal.remove();
  }
  
  // Add modal to DOM
  document.body.insertAdjacentHTML('beforeend', modalHtml);
  
  const modal = new bootstrap.Modal(document.getElementById('addressValidationModal'));
  
  // Handle confirm button
  document.getElementById('confirmAddressBtn').addEventListener('click', function() {
    const selectedSuggestion = document.querySelector('input[name="addressSuggestion"]:checked');
    if (selectedSuggestion) {
      const selectedIndex = selectedSuggestion.value;
      if (selectedIndex === 'original') {
        onConfirm(null);
      } else {
        onConfirm(suggestions[parseInt(selectedIndex)]);
      }
      modal.hide();
    } else {
      showError('Please select an address option');
    }
  });
  
  // Handle cancel
  modal._element.addEventListener('hidden.bs.modal', function() {
    if (onCancel) onCancel();
    this.remove();
  });
  
  modal.show();
}

// DISABLED: Handle address form submission
/*
async function handleAddressSubmit_DISABLED(e) {
  e.preventDefault();

  const formData = new FormData(e.target);
  const addressData = {
    fullName: formData.get('fullName').trim(),
    mobileNumber: formData.get('mobileNumber').trim(),
    altPhone: formData.get('altPhone') ? formData.get('altPhone').trim() : '',
    addressDetails: formData.get('addressDetails').trim(),
    state: formData.get('state'),
    district: formData.get('district'),
    city: formData.get('city').trim(),
    pincode: formData.get('pincode').trim(),
    landmark: formData.get('landmark') ? formData.get('landmark').trim() : '',
    addressType: formData.get('addressType'),
    makeDefault: document.getElementById('makeDefault').checked
  };

  // Show loading state
  const submitBtn = e.target.querySelector('button[type="submit"]');
  const originalText = submitBtn.innerHTML;
  submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Validating...';
  submitBtn.disabled = true;

  try {
    // Step 1: Validate address
    const validation = await validateAddress(addressData);
    
    if (!validation.isValid) {
      showError('Unable to validate the address. Please check your address details and try again.');
      return;
    }

    // Step 2: Check for duplicates (only for new addresses)
    if (!currentEditingId && validation.coordinates) {
      const isDuplicate = checkDuplicateAddress(validation.coordinates, addresses);
      if (isDuplicate) {
        showError('This address appears to be very similar to an existing address. Please check your saved addresses.');
        return;
      }
    }

    // Step 3: Handle address suggestions
    if (validation.suggestions.length > 1) {
      showAddressValidationModal(
        validation.suggestions,
        async (selectedSuggestion) => {
          // Update address data with selected suggestion if any
          if (selectedSuggestion) {
            addressData.coordinates = {
              lat: selectedSuggestion.lat,
              lon: selectedSuggestion.lon
            };
            // Optionally update form fields with corrected data
            if (selectedSuggestion.properties) {
              if (selectedSuggestion.properties.city) {
                addressData.city = selectedSuggestion.properties.city;
              }
              if (selectedSuggestion.properties.state) {
                addressData.state = selectedSuggestion.properties.state;
              }
              if (selectedSuggestion.properties.postcode) {
                addressData.pincode = selectedSuggestion.properties.postcode;
              }
            }
          } else {
            // Use original coordinates
            addressData.coordinates = validation.coordinates;
          }
          
          await submitAddressData(addressData);
        },
        () => {
          // User cancelled - restore button state
          submitBtn.innerHTML = originalText;
          submitBtn.disabled = false;
        }
      );
    } else {
      // Single suggestion or no suggestions - proceed directly
      addressData.coordinates = validation.coordinates;
      await submitAddressData(addressData);
    }

  } catch (error) {
    console.error('Error during address validation:', error);
    showError('Failed to validate address. Please try again.');
  } finally {
    // Restore button state if not handled by modal
    if (!document.getElementById('addressValidationModal')) {
      submitBtn.innerHTML = originalText;
      submitBtn.disabled = false;
    }
  }
}
*/

// Submit address data to backend
async function submitAddressData(addressData) {
  const submitBtn = document.querySelector('#addressForm button[type="submit"]');
  
  try {
    const url = currentEditingId ? `/api/address/${currentEditingId}` : '/api/address';
    const method = currentEditingId ? 'PUT' : 'POST';

    const response = await fetch(url, {
      method: method,
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(addressData)
    });

    const data = await response.json();

    if (data.success) {
      showSuccess(data.message);
      const modal = bootstrap.Modal.getInstance(document.getElementById('addressModal'));
      modal.hide();
      loadAddresses(); // Reload addresses
    } else {
      showError(data.message);
    }
  } catch (error) {
    console.error('Error saving address:', error);
    showError('Failed to save address');
  } finally {
    // Restore button state
    submitBtn.innerHTML = '<i class="fas fa-save"></i> Save Address';
    submitBtn.disabled = false;
  }
}

// Utility functions for notifications
function showSuccess(message) {
  if (typeof Swal !== 'undefined') {
    Swal.fire({
      title: 'Success!',
      text: message,
      icon: 'success',
      confirmButtonColor: '#000000'
    });
  } else {
    alert(message);
  }
}

function showError(message) {
  if (typeof Swal !== 'undefined') {
    Swal.fire({
      title: 'Error!',
      text: message,
      icon: 'error',
      confirmButtonColor: '#000000'
    });
  } else {
    alert(message);
  }
}
</script>